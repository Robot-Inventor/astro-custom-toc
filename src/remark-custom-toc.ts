import type { Html, Node, Nodes, Root } from "mdast";
import { JSDOM } from "jsdom";
import type { Plugin } from "unified";
import Slugger from "github-slugger";
import { visit } from "unist-util-visit";

/**
 * Heading data.
 */
interface Heading {
    slug: string;
    text: string;
    depth: number;
}

/**
 * Custom TOC template function.
 * @param html HTML content of the TOC list
 * @returns Wrapped HTML content
 */
export type RemarkCustomTocTemplate = (html: string) => string;

/**
 * Options for the remarkCustomToc plugin.
 */
export interface RemarkCustomTocOptions {
    /**
     * A function that takes the generated HTML and returns the final HTML.
     * This can be used to wrap the generated HTML in a custom template.
     * @default
     * ```javascript
     * const defaultTemplate = (html) => {
     *     return `
     * <aside class="toc">
     *     <h2>Contents</h2>
     *     <nav>
     *         ${html}
     *     </nav>
     * </aside>`.trim();
     * };
     * ```
     */
    template?: RemarkCustomTocTemplate;
    /**
     * The maximum depth of headings to include in the table of contents.
     * @default 3
     */
    maxDepth?: number;
    /**
     * Whether to use an ordered list (`<ol>`) or an unordered list (`<ul>`).
     * @default false
     */
    ordered?: boolean;
}

interface VFile {
    data: {
        astro?: {
            frontmatter: Record<string, unknown>;
        };
    };
}

/**
 * A comment node generated by the `remark-comment` plugin.
 */
interface Comment extends Node {
    type: "comment";
    value: "";
    commentValue: string;
}

declare module "mdast" {
    // Add the `Comment` node to the list of nodes.
    interface RootContentMap {
        comment: Comment;
    }

    interface Data {
        id: string;
    }
}

/**
 * Default TOC template function for {@link RemarkCustomTocTemplate}.
 * @param html HTML content of the TOC list
 * @returns Wrapped HTML content
 */
const defaultTemplate: RemarkCustomTocTemplate = (html: string): string =>
    `
<aside class="toc">
    <h2>Contents</h2>
    <nav>
        ${html}
    </nav>
</aside>`.trim();

/**
 * Default options for the remarkCustomToc plugin.
 */
const DEFAULT_OPTIONS = {
    maxDepth: 3,
    ordered: false,
    template: defaultTemplate
} as const satisfies Required<RemarkCustomTocOptions>;

/**
 * Check if the node is a `Comment` node with the value "toc".
 * @param node Input node
 * @returns Whether the node is a `Comment` node with the value "toc"
 */
const isTocCommentNode = (node: Nodes): node is Comment =>
    node.type === "comment" && node.commentValue.trim().toLowerCase() === "toc";

/**
 * Generate the table of contents from the headings data.
 * @param options Options for the plugin
 * @param headings Headings data
 * @returns The generated table of contents
 */
// eslint-disable-next-line max-statements
const generateToc = (options: Required<RemarkCustomTocOptions>, headings: Heading[]): Html => {
    const { document } = new JSDOM().window;

    const toc: HTMLElement = document.createElement(options.ordered ? "ol" : "ul");
    let currentDepth = headings[0].depth;
    let currentParent = toc;
    for (const heading of headings) {
        // eslint-disable-next-line no-continue
        if (heading.depth > options.maxDepth) continue;

        if (heading.depth === currentDepth) {
            const li = document.createElement("li");
            const link = document.createElement("a");
            link.href = `#${heading.slug}`;
            link.textContent = heading.text;
            li.appendChild(link);
            currentParent.appendChild(li);
            currentDepth = heading.depth;
        } else if (heading.depth > currentDepth) {
            const ul = document.createElement(options.ordered ? "ol" : "ul");
            const li = document.createElement("li");
            const link = document.createElement("a");
            link.href = `#${heading.slug}`;
            link.textContent = heading.text;
            li.appendChild(link);
            ul.appendChild(li);
            currentParent.appendChild(ul);
            currentParent = ul;
            currentDepth = heading.depth;
        } else {
            // eslint-disable-next-line id-length
            for (let i = 0; i < currentDepth - heading.depth; i++) {
                currentParent = currentParent.parentElement!;
            }
            const li = document.createElement("li");
            const link = document.createElement("a");
            link.href = `#${heading.slug}`;
            link.textContent = heading.text;
            li.appendChild(link);
            currentParent.appendChild(li);
            currentDepth = heading.depth;
        }
    }

    return {
        type: "html",
        value: options.template(toc.outerHTML)
    };
};

/**
 * Remark plugin to generate a table of contents.
 * @param userOptions Options for the plugin
 * @returns The plugin
 */
export const remarkCustomToc: Plugin<[RemarkCustomTocOptions], Root> = (userOptions: RemarkCustomTocOptions) => {
    const options = { ...DEFAULT_OPTIONS, ...userOptions };

    // eslint-disable-next-line max-statements
    return (tree, { data }: VFile) => {
        if (data.astro && data.astro.frontmatter.showToc !== true) return;

        const slugs = new Slugger();
        slugs.reset();

        const headings: Heading[] = [];
        visit(tree, "heading", (node): void => {
            const { depth } = node;
            // eslint-disable-next-line no-extra-parens
            const text = node.children.map((children) => ("value" in children ? children.value : "")).join("");
            const slug = slugs.slug(text);
            node.data = { id: slug };
            headings.push({ depth, slug, text });
        });

        let tocIndex = 0;
        visit<Root, string>(tree, "comment", (node, index) => {
            if (isTocCommentNode(node) && typeof index !== "undefined") {
                tocIndex = index;
            }
        });

        const toc = generateToc(options, headings);
        if (tocIndex) {
            // eslint-disable-next-line no-magic-numbers
            tree.children.splice(tocIndex, 1, toc);
        } else {
            tree.children.unshift(toc);
        }
    };
};
